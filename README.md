<!-- Copyright (c) 2017-2018 Twitter, Inc. -->
<!-- Licensed under the Apache License, Version 2.0 (see LICENSE.md). -->
<!-- Autogenerated by https://github.com/twitter/rsc/tree/8a9b6d57e0cce1b4e6c0e65121bfa39d4e637ccc/bin/bench_upload from https://github.com/twitter/rsc/tree/8a9b6d57e0cce1b4e6c0e65121bfa39d4e637ccc/README.tmpl. -->

# Rsc Performance

Rsc is an experimental Scala compiler focused on compilation speed.
This project is developed by Eugene Burmako and his team at Twitter.

Our research goal is to achieve dramatic compilation speedups (5-10x)
for typical Scala codebases, and we are currently well on track to reaching
this goal.

In this document, we aim to publish the results of running our benchmark suite
on the most recent commit in our repository. Since running benchmarks takes time,
there may be short periods of time when this document is out of date. If you're
curious about the exact version of Rsc that is benchmarked in this document,
[click here](https://github.com/twitter/rsc/commit/db9a696fa09a3d0dbd8e935b32ee3b167b6d5d23).

## Hardware

All benchmarks run on a computer with
Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz (4x32KB+32KB L1 cache,
4x256KB L2 cache, 8192KB L3 cache,
configured to run 4 physical cores and
4 logical cores with Turbo Boost disabled),
31GB RAM and Crucial_CT240M50 disk drive.

## Software

In our benchmarks, we use Debian GNU/Linux 9.4 (stretch) and Java(TM) SE Runtime Environment (build 1.8.0_171-b11)
to run [Rsc 0.0.0-103-db9a696f](https://github.com/twitter/rsc/commit/db9a696fa09a3d0dbd8e935b32ee3b167b6d5d23) and Scalac 2.11.12.
To benchmark JVM applications, we use sbt-jmh 0.2.27 that runs in sbt 0.13.17.

Our benchmarks run different fragments of compilation pipelines of
different compilers on [an automatically rewritten core of [Twitter Util](https://github.com/twitter/util)](https://github.com/twitter/rsc/tree/db9a696fa09a3d0dbd8e935b32ee3b167b6d5d23/examples/core)
that contains 96 files totaling 20143 lines of code.

Every benchmark runs in in hot mode, i.e. it computes performance of a steady
state of the JVM achieved by doing a large number of warmup runs in JMH.

## Disclaimer

At this point, Rsc only implements a subset of functionality provided by the
Scala compiler. This means that the benchmark results provided below must
be interpreted with utmost care. Concretely:
  * Performance numbers may significantly deteriorate as we will be
    implementing more and more functionality of the Scala compiler.
    For example, adding support for implicit search or type inference
    is very likely to slow down our compiler by a significant factor.
  * Direct comparisons of Rsc and Scalac performance numbers should take
    into account similarities and differences in provided functionality.
    Consult [the summary in the "Compiler" document](https://github.com/twitter/rsc/tree/db9a696fa09a3d0dbd8e935b32ee3b167b6d5d23/docs/compiler.md#summary)
    for more information.

## Results

To reproduce, run `bin/bench` (this will take a while).

<table>
  <th>
    <td>Individual</td>
    <td>Cumulative</td>
  </th>
  <tr>
    <td width="208px"><a href="https://github.com/twitter/rsc/tree/db9a696fa09a3d0dbd8e935b32ee3b167b6d5d23/bench/src/main/scala/rsc/bench/RscParse.scala">RscParse</a></td>
    <td width="208px">19.44 ms</td>
    <td width="208px">19.440 ms</td>
  </tr>
  <tr>
    <td><a href="https://github.com/twitter/rsc/tree/db9a696fa09a3d0dbd8e935b32ee3b167b6d5d23/bench/src/main/scala/rsc/bench/RscLink.scala">RscLink</a></td>
    <td>47.548 ms</td>
    <td>66.988 ms</td>
  </tr>
  <tr>
    <td><a href="https://github.com/twitter/rsc/tree/db9a696fa09a3d0dbd8e935b32ee3b167b6d5d23/bench/src/main/scala/rsc/bench/RscOutline.scala">RscOutline</a></td>
    <td>43.541 ms</td>
    <td>110.529 ms</td>
  </tr>
  <tr>
    <td><a href="https://github.com/twitter/rsc/tree/db9a696fa09a3d0dbd8e935b32ee3b167b6d5d23/bench/src/main/scala/rsc/bench/RscSemanticdb.scala">RscSemanticdb</a></td>
    <td>24.33 ms</td>
    <td>134.859 ms</td>
  </tr>
  <tr>
    <td><a href="https://github.com/twitter/rsc/tree/db9a696fa09a3d0dbd8e935b32ee3b167b6d5d23/bench/src/main/scala/rsc/bench/RscMjar.scala">RscMjar</a></td>
    <td>256.421 ms</td>
    <td>391.280 ms</td>
  </tr>
  <tr>
    <td><a href="https://github.com/twitter/rsc/tree/db9a696fa09a3d0dbd8e935b32ee3b167b6d5d23/bench/src/main/scala/rsc/bench/ScalacCompile.scala">ScalacCompile</a></td>
    <td>3838.347 ms</td>
    <td>3838.347 ms</td>
  </tr>
</table>

## Summary

At the moment, generating SemanticDB signatures from an automatically rewritten core of [Twitter Util](https://github.com/twitter/util)
is ~28x faster than full Scalac compilation.
Generating ScalaSignatures is is ~10x faster.
