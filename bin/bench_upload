#!/usr/bin/env python
# -*- coding: utf-8 -*-
import collections, json, os, re, string, sys
from common import *

if len(sys.argv) != 5:
  print "usage: " + sys.argv[0] + " <target_user> <target_repo> <target_sha> <bin_bench_path>"
  sys.exit(1)
def slurp(path):
  with open(path, "r") as file: return file.read()
target_ref = GithubRef(sys.argv[1], sys.argv[2], sys.argv[3])
bin_bench_path = sys.argv[4]
print "Reading " + bin_bench_path + "..."
bin_bench_stdout = slurp(bin_bench_path)

cd(".")
props = {}
props["CurrentDate"] = utc(stdout("date +'" + date_format + "'"))

print ""
print "Computing generator props..."
binary_path = os.path.abspath(sys.argv[0])
root_ref = github_ref(os.path.dirname(binary_path))
props["SoftwareGenerator"] = root_ref.resolve_remote(binary_path)

print ""
print "Computing paths..."
target_ref.download_ssh()
cd(target_ref.path)
bench_path = target_ref.resolve_local("bench")
target_path = target_ref.resolve_local("examples/core")
properties_path = target_ref.resolve_local("project/build.properties")
plugins_path = target_ref.resolve_local("project/plugins.sbt")
travis_path = target_ref.resolve_local(".travis.yml")

print ""
print "Computing git props..."
props["GitUser"] = target_ref.user
props["GitRepo"] = target_ref.repo
props["GitSha"] = target_ref.sha
props["GitFullSha"] = target_ref.sha
props["GitShortSha"] = target_ref.sha[:8]
props["GitDate"] = utc(stdout("git show -s --format=%ci " + target_ref.sha))

print ""
print "Computing hardware props..."
if sys.platform == "darwin":
  props["HardwareCpu"] = stdout("sysctl -n machdep.cpu.brand_string")
  props["HardwarePhysicalCores"] = stdout("sysctl -n hw.physicalcpu")
  props["HardwareLogicalCores"] = stdout("sysctl -n hw.logicalcpu")
  props["HardwareL1dCache"] = str(int(stdout("sysctl -n hw.l1dcachesize"))/1024) + "KB"
  props["HardwareL1iCache"] = str(int(stdout("sysctl -n hw.l1icachesize"))/1024) + "KB"
  props["HardwareL2Cache"] = str(int(stdout("sysctl -n hw.l2cachesize"))/1024) + "KB"
  props["HardwareL3Cache"] = str(int(stdout("sysctl -n hw.l3cachesize"))/1024) + "KB"
  props["HardwareTurboBoost"] = "Turbo Boost enabled"
  props["HardwareRam"] = str(int(stdout("sysctl -n hw.memsize"))/(1024*1024*1024)) + "GB"
  props["HardwareDiskDrive"] = stdout("system_profiler SPSerialATADataType | grep Model | awk -F':' '{print $2}'")
elif sys.platform.startswith("linux"):
  props["HardwareCpu"] = stdout("lscpu | grep '^Model name' | awk -F':' '{print $2}'")
  props["HardwarePhysicalCores"] = stdout("lscpu | grep '^CPU(s):' | awk -F':' '{print $2}'")
  threads_per_core = stdout("lscpu | grep '^Thread(s) per core:' | awk -F':' '{print $2}'")
  props["HardwareLogicalCores"] = str(int(props["HardwarePhysicalCores"]) * int(threads_per_core))
  props["HardwareL1dCache"] = stdout("lscpu | grep '^L1d cache:' | awk -F':' '{print $2}'") + "B"
  props["HardwareL1iCache"] = stdout("lscpu | grep '^L1i cache:' | awk -F':' '{print $2}'") + "B"
  props["HardwareL2Cache"] = stdout("lscpu | grep '^L2 cache:' | awk -F':' '{print $2}'") + "B"
  props["HardwareL3Cache"] = stdout("lscpu | grep '^L3 cache:' | awk -F':' '{print $2}'") + "B"
  def turbo_boost():
    # NOTE: We expect that Turbo Boost is disabled on our Linux benchbox.
    # If that's not the case, bin/bench_environment will let us know.
    #
    # curr_core = 0
    # max_cores = int(props["HardwarePhysicalCores"])
    # while curr_core < max_cores:
    #   turbo_boost_off = stdout("sudo rdmsr -p" + str(curr_core) + " 0x1a0 -f 38:38")
    #   if turbo_boost_off == "0": return "Turbo Boost enabled"
    #   curr_core += 1
    return "Turbo Boost disabled"
  props["HardwareTurboBoost"] = turbo_boost()
  props["HardwareRam"] = "{0:.0f}".format(int(stdout("cat /proc/meminfo | grep '^MemTotal:' | awk -F' ' '{print $2}'"))/(1024 * 1024)) + "GB"
  props["HardwareDiskDrive"] = stdout("cat /sys/class/block/sda/device/model")
else:
  raise Exception("unsupported platform " + sys.platform)

print ""
print "Computing software props..."
if sys.platform == "darwin": props["SoftwareOperatingSystem"] = "macOS " + stdout("defaults read loginwindow SystemVersionStampAsString")
elif sys.platform.startswith("linux"): props["SoftwareOperatingSystem"] = stdout("lsb_release -a 2>&1 | grep '^Description:' | awk -F':' '{print $2}'")
else: raise Exception("unsupported platform " + sys.platform)
props["SoftwareKernel"] = stdout("uname -rs")
props["SoftwareJre"] = stdout("java -version 2>&1 | head -n 2 | tail -1")
props["SoftwareRsc"] = "Rsc " + stdout("sbt -no-colors 'show rsc/version' | tail -n 1 | awk -F'] ' '{ print $2 }'")
props["SoftwareScalac"] = "Scalac " + stdout("grep 2.11 " + travis_path + " | head -n 1 | awk -F': ' '{print $2}'")
props["SoftwareSbt"] = "sbt " + stdout("grep sbt.version " + properties_path + " | awk -F'=' '{print $2}'")
props["SoftwareSbtJmh"] = "sbt-jmh " + stdout("grep sbt-jmh " + plugins_path + " | awk -F'\"' '{print $6}'")
props["SoftwareTargetDescription"] = "an automatically rewritten core of [Twitter Util](https://github.com/twitter/util)"
props["SoftwareTargetUrl"] = target_ref.resolve_remote(target_path)
props["SoftwareTargetFiles"] = stdout("find " + target_path + " -type f -name '*.scala' | wc -l")
props["SoftwareTargetLoc"] = stdout("cloc --quiet --csv " + target_path + " | grep Scala | awk -F',' '{print $3+$4+$5}'")

def find_bench_path(bench):
  paths = stdout("find " + bench_path + " -name '" + bench + ".scala'").split("\n")
  if len(paths) == 1: return paths[0]
  else: raise Exception("can't find " + bench + ".scala in " + bench_path)
def find_bench_result(bench):
  m = re.search(bench + r"\.run\s+\w+\s+\d+(.*?)ms/op", bin_bench_stdout)
  if m: return m.groups()[0].strip() + " ms"
  else: raise Exception("can't find " + bench + " in " + bin_bench_path)
def parse_bench_result(bench):
  result = find_bench_result(bench)
  m = re.match(r"^(?P<score>[\d\.]+)\s+Â±\s+(?P<error>[\d\.]+) (?P<unit>.*)$", result)
  if m:
    d = collections.defaultdict(lambda: "", m.groupdict())
    return (d["score"], d["error"], d["unit"])
  else:
    raise Exception("can't parse " + bench + " in " + bin_bench_path)
def populate_bench_props(curr_bench, prev_bench):
  props["Bench" + curr_bench + "Label"] = curr_bench
  props["Bench" + curr_bench + "Url"] = target_ref.resolve_remote(find_bench_path(curr_bench))
  (curr_score, curr_error, curr_unit) = parse_bench_result(curr_bench)
  if prev_bench: (prev_score, prev_error, prev_unit) = parse_bench_result(prev_bench)
  else: (prev_score, prev_error, prev_unit) = ("0.0", "0.0", curr_unit)
  props["Bench" + curr_bench + "Score"] = curr_score
  props["Bench" + curr_bench + "CumulativeScore"] = curr_score
  try: props["Bench" + curr_bench + "IndividualScore"] = str(float(curr_score) - float(prev_score))
  except: props["Bench" + curr_bench + "IndividualScore"] = ""
  props["Bench" + curr_bench + "Error"] = curr_error
  props["Bench" + curr_bench + "Unit"] = curr_unit
print ""
print "Computing bench props..."
populate_bench_props("RscParse", None)
populate_bench_props("RscLink", "RscParse")
populate_bench_props("RscOutline", "RscLink")
populate_bench_props("RscSemanticdb", "RscOutline")
populate_bench_props("RscMjar", "RscSemanticdb")
populate_bench_props("ScalacCompile", None)

print ""
print "Computing document props..."
props["LinkRsc"] = target_ref.url
props["LinkCompilerSummary"] = target_ref.resolve_remote("docs/compiler.md#summary")

print ""
print "Computing summary props..."
cumulative_semanticdb = float(props["BenchRscSemanticdbCumulativeScore"])
cumulative_mjar = float(props["BenchRscMjarCumulativeScore"])
cumulative_scalac = float(props["BenchScalacCompileScore"])
semanticdb_speedup = cumulative_scalac / cumulative_semanticdb
mjar_speedup = cumulative_scalac / cumulative_mjar
props["SummarySemanticdbSpeedup"] = "{0:.0f}".format(semanticdb_speedup)
props["SummaryMjarSpeedup"] = "{0:.0f}".format(mjar_speedup)

print ""
print "Downloading performance repository..."
performance_ref = GithubRef(root_ref.user, root_ref.repo, "performance")
performance_ref.download_ssh()
cd(performance_ref.path)
performance_json_path = performance_ref.resolve_local("performance.json")
performance_json = []
with open(performance_json_path, "r") as performance_json_file:
  performance_json = json.load(performance_json_file)

print ""
print "Updating performance repository..."
performance_json = filter(lambda json: json["GitFullSha"] != target_ref.sha, performance_json)
performance_json.append(props)
performance_json.sort(key=lambda json: json["GitDate"])
latest_props = performance_json[-1]
with open(performance_json_path, "w") as performance_json_file:
  json.dump(performance_json, performance_json_file, indent=2, sort_keys=True, ensure_ascii=False)
for file_name in os.listdir(root_ref.path):
  (file_base, file_ext) = os.path.splitext(file_name)
  if file_ext == ".tmpl":
    tmpl_path = root_ref.resolve_local(file_name)
    print "Reading " + tmpl_path + "..."
    tmpl_contents = slurp(tmpl_path)
    latest_props["CurrentTemplate"] = root_ref.resolve_remote(tmpl_path)
    doc_path = performance_ref.resolve_local(file_base + ".md")
    doc_contents = string.Template(tmpl_contents).substitute(latest_props)
    print "Writing " + doc_path + "..."
    with open(doc_path, "w") as doc_file: doc_file.write(doc_contents)
run("git add -A")
run("git commit -m '" + target_ref.url + "'")

print ""
print "Uploading performance repository..."
run("git push origin performance")
performance_ref.sha = stdout("git rev-parse HEAD")
print "Uploaded to " + performance_ref.url

print ""
print "Cleaning up..."
target_ref.cleanup()
performance_ref.cleanup()
